*객체 (Object)
-> 데이터(프로퍼티)와 그 데이터에 관련되어 있는 동작(메소드)을 포함하고 있는 것
-> (한마디로 하자면) 자신의 정보를 갖고 있는 독립적인 주체 

*프로퍼티 (Property)
-> 객체가 갖고 있는 데이터 또는 값
-> 직접적으로 접근 가능하게 할 수도 있고, 메서드를 통해서 간접적으로 접근하게 할 수도 있다

*메소드 (Method)
-> 객체가 갖고 있는 동작
-> 메소드 vs 함수
	- 공통점 : '동작'이 정의되어 있음
	- 차이점 : 메소드 동작의 주체 = 객체, 함수 동작의 주체 = 없음

*객체, 프로퍼티, 메소드 참고 글
http://insanehong.kr/post/javascript-object/

* 생성자
-> 객체를 생성할 때 사용하는 함수
-> ex) var student = new Student("name",age);

* prototype
-> 사전적 의미 : 원형, 본형, 원작...
-> 프로토 타입을 사용하는 이유 : 쉽게 얘기하면 중복의 제거를 하기 위함.
예를 들어서, person 이라는 객체가 있고, 그 객체는 1개의 메소드를 갖고 있다고 가정해보자.
만약 100개의 person 객체를 생성하면, 그에 따라서 같은 역할을 하는 메소드도 100개가 생성이 된다.
따라서 불필요하게 메모리를 잡아먹게 된다.
1개의 프로토 타입을 만들어서 필요한 경우에 호출하는 형식으로 사용한다면, 각 객체는 가벼워질 것이다.
-> 정의 : 객체들간의 프로퍼티와 메소드를 공유하기 위해서 사용하는 객체
-> 사용 예시 : 중복 제거, 객체 상속

* 생성자, 프로토타입 참고 글
https://doitnow-man.tistory.com/132

* 플라이급 패턴
-> 같은 객체를 관리할 때 각 개체의 고유한 데이터들과 여러 개체가 공통적으로 갖고 있어야할 데이터를 분리하는 방식
-> 객체의 공통된 부분을 프로토타입으로 관리해서 메로리를 절약할 수 있다.

* this
-> 특정 동작이 수행되는 경우 그 동작의 주체가 되는 객체를 가리킨다.
-> 위의 경우가 아닐 때 this를 사용하는 경우 "window"객체를 가리키게 된다.
-> this 의 사용 : this는 해당 구문의 객체를 가리키거나 해당 구문의 객체가 없으면 상위 객체를 가리킨다.
	1) 일반 함수 : this = window (전역객체) (함수가 소속되어 있는 객체를 가리킴)
	2) 이벤트 : this = 이벤트 객체 
	3) 메소드 : this = 메소드가 있는 객체
	4) 메소드 내부의 중첩 함수 : this = window (전역객체) (**헷갈리기 쉬움)
	5) 생성자 : this = 생성될 객체

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

* 익명함수
-> var temp = function(){...} 중에서 우변이 익명함수. 익명함수만 따로 사용할 수 있음
-> '람다(lambda)'와 같이 활용 됨

* 콜백
-> 콜백이란, 다른 함수가 실행을 끝낸 뒤 실행되는 것을 말한다

* 콜백함수
-> js 에서 함수는 객체이다. 이 때문에 함수는 다른 함수의 인자로 쓰일 수도 있고,
어떤 함수의 리턴 값이 될 수도 있다. 이 때, 인자로 넘겨지는 함수를 '콜백 함수'라고 한다
-> 비동기 문제를 해결할 때 많이 사용됨.
	ex) 두 개의 함수 A, B가 있다.
	개발자는 A의 동작이 완료된 후, 그 결과를 토대로 B가 실행되기를 원한다.
	하지만 js 는 A,B가 동시에 동작하므로 개발자가 원하는 결과가 나오지 않을 수 있다.
	따라서 B의 로직을 콜백함수에 담아서 A 함수에 인자로 넘긴 후에
	A 함수 내에서 원하는 로직을 설계하면	개발자가 원하는 대로 결과를 얻을 수 있게 된다.
	
	[before]
	>> A(){...}
	>> B(){...}
	
	[after]
	>> A(B){}
	>> B(){...}

* 클로저
-> 외부 함수의 지역 변수에 접근할 수 있는 내부함수를 '클로저'라고 한다.
-> private 변수를 만들 수 있게 된다. (*참고 영상 : https://www.youtube.com/watch?v=J0Qb2wjm-ik&list=PLuHgQVnccGMA4uSig3hCjl7wTDeyIeZVU&index=67)
-> 동기, 비동기 실행 문제를 해결할 수 있다.

* 스코프
-> 어떤 변수들에 접근할 수 있는지를 정의하는 것.
-> 전역 스코프 : 변수가 함수 바깥 or 중괄호{} 바깥에 선언되었다면, '전역 스코프'에 정의됨
-> 지역 스코프
	- 함수 스코프 : 함수 내부에서 변수를 선언하면, 그 변수는 함수 내부에서만 접근할 수 있고 이는 '함수 스코프'에 정의됨
	- 블록 스코프 : 중괄호{} 내부에서 const 또는 let 으로 변수를 선언하면, 그 변수들은 중괄호 내부에서만 접근할 수 있다.
-> 함수가 다른 함수 내부에서 정의되었다면, 내부 함수는 외부 함수의 변수에 접근할 수 있다. 이를 렉시컬 스코핑(lexical scoping)이라고 부른다.
-> 어떠한 함수 또는 동작이 실행된 경우 ( local => global )의 방향으로 식별자(identifier)를 찾게 되고, 해당하는 식별자가 있으면 그 식별자로 동작을 수행하고,
식별자가 없다면 에러를 출력한다. 이처럼 식별자를 찾는 과정을 스코프 체인이라고 한다. 
(** 어떤 객체의 property를 찾는 과정 = 프로토타입 체인)

* 스코프 관련 참고 블로그
https://tyle.io/blog/54

* 호이스팅(Hoisting)
-> hoist 의 사전적 의미 = '끌어올리기'
-> 호이스트란, 변수의 정의가 그 범위에 따라 선언과 할당으로 분리되는 것을 의미한다.
예를 들어서 변수가 함수 내에서 정의되었을 경우, 그 변수의 선언은 함수의 최상위에서 실행된다.
-> 함수의 선언과 실행 또한 마찬가지이다. 함수가 어떤 유효범위의 제일 아래에 선언되어 있어도, 실제로는 최상위에서 선언된다.
*호이스팅 참고 블로그
https://asfirstalways.tistory.com/197

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

* 실행 컨텍스트 (Execution Context)
-> 정의 : 실행 가능한 코드를 형상화하고 구분하는 추상적인 개념 or 실행 가능한 코드가 실행되기 위해 필요한 환경
-> 물리적으로는 객체의 형태를 가지며 아래의 3가지 프로퍼티를 갖는다
	1) Variable object (변수 객체) : 실행에 필요한 여러 정보들을 담을 객체
		- 변수, 매개변수(parameter), 인수정보(arguments), 함수 선언의 정보를 담고 있다
		- >> function func1 (temp) {...};
		- >> func1( "hello" );
		- temp = 매개변수(parameter), "hello" = 인수(or 인자, argument)
		++ arguments 객체 : 함수에서 '인자'로 받은 값을 가리키는 객체. (배열과 거의 유산한 형식이여서 배열의 기능들을 거의 모두 사용할 수 있다)
	2) Scope chain
	3) this value

-> 전역 컨텍스트인 경우 : 변수 객체는 유일하며 최상위에 위치하고, 모든 전역 변수, 전역 함수등을 포함하는 전역 객체를 카리킨다.

-> 함수 컨텍스트인 경우 : 변수 객체는 활성 객체(Activation Object)를 가리키며 매개변수와 인수들의 정보를 배열의 형태로 담고 있는 객체인 arguments object가 추가된다.


-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

e.currentTarget VS e.target
-> e.currentTarget : 이벤트 리스너를 직접 설정한 것을 가리킴
-> e.target : 이벤트가 실제로 동작하는 것을 가리킴

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

* Window 객체 (BOM)
-> 브라우저 전체를 담당하는 객체
-> 브라우저 상단 탭, 주소창, 툴바등등

* Document 객체 (DOM)
-> 웹 페이지를 담당하는 객체
-> 웹 페이지에 존재하는 HTML요소에 접근하고자 한다면 Document객체부터 시작해야함

* 지역변수 (local variables)
-> 함수 내부에서만 접근 가능한 변수

* 전역변수 (global variables)
-> 어플리케이션 전체에서 접근할 수 있는 변수

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

* 호출스택, 백그라운드, 테스크 큐, 이벤트 루프
-> 자바스크립트가 동작하는 환경을 구성하는 개념들.
-> 호출스택 : 함수와 같은 구문이 선언되면 순서대로 호출스택에 쌓인다. 선입선출로 실행됨.
-> 백그라운드 : 호출스택에서 하나씩 동작들을 수행하는 중, setInterval과 같은 비동기 동작들을 백그라운드에 저장한다.
-> 테스크 큐 : 백그라운드에 저장되어 있던 동작이 실행되어야 하는 순간이 오면 테스크 큐로 그 동작을 보낸다.
	      호출스택이 비어 있으면 테스크 큐에 있는 동작이 호출스택으로 올라간다. (우선 순위에 따라서)
-> 이벤트 루프 : 위의 환경들을 loop하면서 각 환경들의 상태나 어떤 동작or구문들이 있는지 파악하는 알고리즘.

* es2015최신문법 : const, let, 화살표 함수
-> const, let : 변수 or 함수를 선언할 때 사용함. var 대신 사용. 
	      const = 상수or 변하지 않는 것 / let = 변수or 변하는 것
-> var = 함수 스코프
-> const, let = 블록 스코프
-> fucntion 함수명(인자){} == const 함수명 =(인자)=>{}
-> 위의 표현들은 거의 유사. 차이점 : this 가 다름.
-> 화살표 함수의 줄임표현 (함수의 동작문에 return 값만 있는 함수인 경우)
const 함수명 = () => {리턴값}
const 함수명 = () => 리턴값

* 최신문법 : spread
-> [...Array(숫자).keys()]  === [0,1,2,...,숫자-1] 이라는 배열을 만듬
-> 만약 2부터 100까지 만들고 싶다면 : [...Array(98).keys().map((v) => v+1)]
-> ...[1,2,3] = 1,2,3
    배열을 풀어줌
-> 배열뿐만 아니라 객체에도 사용할 수 있음
